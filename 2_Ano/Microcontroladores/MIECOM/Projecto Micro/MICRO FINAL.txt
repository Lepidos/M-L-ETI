;#########################################
;#SIMULAÇÃO TRANSMISSAO/RECEPÇÃO DE DADOS#
; 15/12/2010							 #
; ANTÓNIO MAIO 60142					 #
; JOÃO VILELA  58665					 #
; MIECOM - LC3 - 2ºANO					 #
;#########################################

INICIO:
		TECLA EQU 030h	  ; ARMAZENAR TECLA
		TXPTR EQU 040h    ; STRING INICIA NA POSIÇAO 40h
		
		MOV R0,#TECLA     ; MOVE 30H PARA R0
		MOV R1,#TXPTR	  ; MOVE 40h PARA R1
		MOV R2, #4	      ; COMPRIMENTO CODIGO

		TABLE_7SEG EQU 060h	  ; INICIO DA TABELA DE CONFIGURAÇÃO PARA DISPLAY 7-SEG
		MOV R3,#TABLE_7SEG	  ; R3 CONTEM INICIO DA TEBELA (POSIÇÃO)
	
		MOV	P1,#07h	 		  ;INICIALIZAR DISPLAY (JÁ COM A LOGICA INVERTIDA)

Mov 60h,#11101101b;0	      ; MASCARAS PARA DISPLAY 7 SEGMENTOS
Mov 61h,#00000101b;1
Mov 62h,#01111100b;2
Mov 63h,#01011101b;3
Mov 64h,#10010101b;4
Mov 65h,#11011001b;5
Mov 66h,#11111001b;6
Mov 67h,#00001101b;7

;---------------------------------------------------------------------------------
;CONFIGURAÇÃO DA PORTA SERIE

SERIE_CONF:

MOV TMOD, #020h 	; CONFIGURAR TIMER 1 NO MODO 2
MOV TH1 , #0F3h		; GERAR BAUD RATE 2400
MOV SCON, #050h		; CONFIGURAR PORTA SERIE NO MODO 1 
SETB TR1			; ARRANCAR TIMER 1 RESPONSEVEL PELA GERAÇÃO DO BAUD RATE

;---------------------------------------------------------------------------------
;LER TECLA PREMIDA
LER_TECLA:	
			MOV A,P2           ; P2 = 11111111b (INICIALMENTE COMTEM ESTE VALOR POIS NAO ESTAMOS A PREMIR)
			MOV B,A		       ; SALVAGUARDAR VALOR DE A
			XRL A,#11111111b   ; VERIFICAR SE FOI PREMIDA UMA TECLA			
			JZ LER_TECLA	   ; SE NAO FOI VOLTAMOS A LER
			JMP DESC_TECLA	   ; SE FOR ZERO PROCEDEMOS Á SUA DESCODIFICAÇÃO

;--------------------------------------------------------------------------------			
;VALIDAÇÃO DE TECLA

VAL:							
			MOV R0,#TECLA	  ;	R0 FICA COM O VALOR ONDE VAMOS COLOCAR A TECLA PREMIDA
			MOV @R0,A	      ; COLOCA O QUE ESTA NO ACC NA POSIÇAO APONTADA POR R0
			JMP AINDA_TECLA	  ; VERIFICA SE AINDA ESTAMOS A PREMIR A TECLA PARA LIGAR OS DISPLAYS

;-----------------------------------------------------------------------------------------------
;DESCODIFICA QUE TECLA FOI PREMIDA
DESC_TECLA:					 
			MOV A,B		 ; B CONTEM VALOR DA LINHA ESCOLHIDA EM P2
			XRL A,#0FEh	 ; VERIFICAR SE É LINHA ZERO	
			JZ ZERO		 ; SE A=0 SALTA PARA ROTINA QUE DEFINE NUMERO ZERO

			MOV A,B
			XRL A,#0FDh	; VERIFICAR SE É LINHA UM
			JZ UM	    ; SE A=0 SALTA PARA ROTINA QUE DEFINE NUMERO UM

			MOV A,B
			XRL A,#0FBh	 ; VERIFICAR SE É LINHA DOIS
			JZ DOIS	     ; SE A=0 SALTA PARA ROTINA QUE DEFINE NUMERO DOIS

			MOV A,B
			XRL A,#0F7h	 ; VERIFICAR SE É LINHA TRES
			JZ TRES	     ; SE A=0 SALTA PARA ROTINA QUE DEFINE NUMERO TRES

			MOV A,B
			XRL A,#0EFh	 ; VERIFICAR SE É LINHA QUATRO
			JZ QUATRO    ; SE A=0 SALTA PARA ROTINA QUE DEFINE NUMERO QUATRO

			MOV A,B
			XRL A,#0DFh	 ; VERIFICAR SE É LINHA CINCO
			JZ CINCO     ; SE A=0 SALTA PARA ROTINA QUE DEFINE NUMERO CINCO

			MOV A,B
			XRL A,#0BFh	 ; VERIFICAR SE É LINHA SEIS
			JZ SEIS	     ; SE A=0 SALTA PARA ROTINA QUE DEFINE NUMERO SEIS

			MOV A,B
			XRL A,#07Fh	 ; VERIFICAR SE É LINHA SETE
			JZ SETE	     ; SE A=0 SALTA PARA ROTINA QUE DEFINE NUMERO SETE
;--------------------------------------------------------------------------

;MANDAR PARA O ACC O VALOR REAL DA TECLA
ZERO:
		MOV A,#0  ; COLOCA O RESPECTIVO VALOR DA TECLA CONSOANTE A LINHA ESCOLHIDA
		MOV B,A	  ; SALVAGUARDAR VALOR DA TECLA
		JMP VAL	  ; PROCEDER Á VALIDAÇÃO

UM:
		MOV A,#1
		MOV B,A
		JMP VAL

DOIS:
		MOV A,#2
		MOV B,A
		JMP VAL

TRES:
		MOV A,#3
		MOV B,A
		JMP VAL

QUATRO:
		MOV A,#4
		MOV B,A
		JMP VAL

CINCO:
		MOV A,#5
		MOV B,A
		JMP VAL
		
SEIS:
		MOV A,#6
		MOV B,A
		JMP VAL
		
SETE:
		MOV A,#7
		MOV B,A
		JMP VAL
		
	
;-------------------------------------------------------------------------------

;VERIFICA SE A TECLA AINDA ESTÁ A SER PREMIDA
AINDA_TECLA:			
				//MOV B,A	     
		LOOP:	MOV A,#0FFh	 		; ACC FICA COM FFh
				XRL A,P2			; VERIFICAR SE AINDA ESTAMOS A PREMIR A TECLA
				JNZ LIGA_DISPLAY  	; SE NAO FOR 0, SIGNIFICA QUE AINDA ESTAMOS A PREMIR ENTAO LIGAMOS DISPLAY
				MOV P1,#0FFh		; SE FOR 0 , JA NAO ESTAMOS A PREMIR E DESLIGAMOS O DISPLAY
				JZ MOVER_MEM		; COLOCAR EM MEMORIA A TECLA
;--------------------------------------------------------------------------------

;LIGA O NUMERO CORRESPONDENTE NO DISPLAY
LIGA_DISPLAY:
			 
			MOV A,B		   ; B CONTEM O VALOR SEMPRE O VALOR DA TECLA PREMIDA
			ADD A,R3       ; OBTER A MASCARA DA TECLA PREMIDA
			MOV R0,A	   ; MOVER PARA R0 A MASCARA
			MOV A,@R0	   ; MOVER PARA ACC O CONTEUDO DA MASCARA 
			CPL A		   ; COMPLEMENTO (LOGICA INVERTIDA DO DISPLAY)
			MOV P1,A	   ; MOVER A CONFIGURAÇÃO PARA O PORTO 1
			CALL ESPERA	   ; EFECTUA UM COMPASSO DE ESPERA
			JMP LOOP	   ; SLATA PARA LOOP PARA VERIFICAR SE AINDA ESTA A SER PREMIDA A TECLA
		
;---------------------------------------------------------------------------------

;COLOCA EM MEMORIA AS TECLA PREMIDAS
MOVER_MEM:					   
		    MOV A,B	   		; B CONTEM VALOR DA TECLA E COPIA-SE PARA ACC
			ADD A,#030h		; MOVER PARA A MEMORIA O VALOR JÁ EM ASCII DA TECLA
			MOV @R1,A		; MOVER TECLA PARA A POSIÇAO APONTADA POR R1 (TXPTR)
			JMP MOVER_SBU	; MOVER PARA BUFFER DE TRANSMISSÃO

;------------------------------------------------------------------------------------
;MOVER DIGITO INSERIDO PARA BUFFER DE TRANSMISSAO
MOVER_SBU: 		
				MOV A,@R1	  			; MOVE PARA ACC CONTEUDO APONTADO POR TXPTR 
				CLR TI					; LIMPA TI PARA TRANSMITIR
				MOV SBUF,A	  		    ; MOVER PARA BUFFER DE TRANSMISSÃO A TECLA
				JNB TI,$				; ESPERA QUE TI VENHA A UM  - SIGNIFICA QUE ACABOU DE TRANSMITIR
				INC R1					; INCREMENTAR R1 PARA AVANÇAR O TXPTR PARA A PROXIMA POSIÇAO DE MEMORIA
				DJNZ R2,LER_DE_NOVO     ; ENQUANTO R2 NAO FOR 0, LÊ OUTRA TECLA
				JMP FIM_CODIGO_UT		; ACABOU DE INSERIR OS 4 DIGITOS 

;-------------------------------------------------------------------------------------------
;LE TECLA SEGUINTE
LER_DE_NOVO:
			
			MOV P1,#0FFh		 ; DESLIGA DISPLAY
			JMP LER_TECLA		 ; LE NOVA TECLA

;-------------------------------------------------------------------------------------------
;FIM DE INSERÇAO DOS 4 DIGITOS
FIM_CODIGO_UT:
			
			MOV P1,#04Ah  	  	; SIGNIFICA QUE ACABAMOS DE INSERIR O CODIGO DE UTILIZADOR (LETRA H)
			CALL ESPERA			; EFECTUAR COMPASSO DE ESPERA
			CALL ESPERA			;
			JMP INICIO_RX		; PREPARAR PARA RECEBER DADOS DO SC


;----------------------------------------------------------------

;ROTINA DE PAUSA 
ESPERA: 							   
			MOV R5,#00dh 
volta1: 	MOV R6,#07ah 
volta2: 	MOV R7,#0ffh 
ciclo: 		DJNZ R7,CICLO  ; Repete até R7=0 
			DJNZ R6,VOLTA2 ; Repete até R7=R6=0
			DJNZ R5,VOLTA1 ; Repete até R7=R6=R5=0
			RET 		   ; RETORNO

;-------------------------------------------------------------------------------------------
/*
;ROTINA DE CONFIGURAÇÃO PARA O TIMER 0	 (DELAY)

TIMER0_CONG:
 
			MOV R4,#15 

ciclo_timer: 
			CLR TF0		  			; FLAG TRANSBORDO
			MOV TH0,#0FH 			; REGISTOS DE CONTAGEM
			MOV TL0,#0FCH  			; RGISTOS DE CONTAGEM
			
			MOV TMOD, #01h			; DEFINIR MODO 1 DE OPERAÇÃO (16 BITS TH E TL)
			SETB TR0 				; começa a contar
			JNB TF0,$ 				; espera pelo fim da contagem
			DJNZ R4,ciclo_timer 	; até fazer as 15 contagens de 61444
			RET

*/
;--------------------------------------------------------------------------------------------
;--------------------------------------------------------------------------------------------

;# RECEPÇÃO #
;###########

;PC PROCEDE Á VALIDAÇÃO DO CODIGO E MICRO RECEBE O BYTE	CORRESPONDENTE

CLR TI		   ; LIMPA VALOR DE TI
MOV P1,#0FFh   ; DESLIGA O DISPLAY

INICIO_RX:
			
	MOV R0,#30h			   ; MOVER PARA R0 VALOR 30h
	
;---------------------------------------------------------------------------------------------------

;VERIFICA SE ESTÁ A CHEGAR UM BYTE DO CANAL SERIE
RX_SERIE:						
		   JNB RI,RX_SERIE		; ENQUANTO RX NAO FOR 1 FICA NESTE LOCAL
		   MOV A,SBUF
		   MOV @R0,A
		   CLR RI				; LIMPA VALOR DE RI
		   JMP VAL_BYTE

RX_SERIE_2:
			JNB RI,RX_SERIE_2
			MOV A,SBUF
			MOV @R0,A
			CLR RI
			JMP COFRE_FUNC
;----------------------------------------------------------------------------------------------------

;VALIDAÇAO DO BYTE
VAL_BYTE:					  
		MOV A,@R0			  ;SE FOR 00h SIGNIFICA QUE CODIGO INSERIDO É INVALIDO E TEM DE VOLTAR A INSERIR
		XRL A,#0FFh
		JZ FIM_ERRO			  ; 
		

;VERIFICA SE O BYTE RECEBIDO É O DOS RECURSOS OU DE LOGOUT (ARBITROU-SE E0h)
VAL_BYTE_LOGOUT:			  
		MOV A,@R0			  ; MOVER PARA ACC O BYTE 
		XRL A,#0E0h			  ; SE A=0 SIGNIFICA QUE O BYTE RECEBIDO FOI DE LOGOUT
		JZ FIM_SUCESSO		  ; LOGOUT EFECTUADO COM SUCESSO
		JNZ SALA			  ; SIGNIFICA QUE É UM BYTE DE RECURSOS
;----------------------------------------------------------------------------------------------------		

;APRESENTAM NO DISPLAY SIMBOLOS DE FINALIZAÇÃO E VOLTA AO INICIO
FIM_ERRO:
		MOV P1,#0CEh   ; CONFIGURAÇÃO PARA LETRA (N)
		CALL ESPERA	   ; COMPASSO DE ESPERA
		CALL ESPERA    ;
		JMP  INICIO	   ; TEM DE VOLTAR INSERIR DE NOVO

FIM_SUCESSO:
 		MOV P1,#000h	; CONFIGURAÇAO PARA (8.) , SIGNIFICA LOGOUT COM SUCESSO
		CALL ESPERA		; COMPASSO DE ESPERA
		CALL ESPERA		;
		JMP INICIO	    ; VOLTA AO INICIO PARA UMA NOVA INSERÇAO DE OUTRO UTILIZADOR 

;---------------------------------------------------------------------------------------------------

;ROTINA QUE DÁ O VALOR DA SALA E MOSTRA NO DISPLAY
SALA: 
				
		MOV R1,#031h			; MOVER PARA R1 VALOR 31h
		MOV A,@R0				; MOVER VALAO DA SALA PARA ACC
		ADD A,#030h				; OBTER A MASCARA PARA NUMERO DA SALA
		MOV R1,A				; MOVER MASCARA PARA R1
		MOV A,@R1				; MOVER PARA ACC CONTEUDO DA MASCARA
		CPL A					; COMPLEMENTO (LOGICA INVERTIDA DO DISPLAY)
		MOV P1,A				; MOSTRAR NO DISPLAY
		CALL ESPERA				; COMPASSO DE ESPERA
		CALL ESPERA				;
		JMP RX_SERIE_2

;---------------------------------------------------------------------------------------------------
;VERIFICA SE É CLIENTE OU FUNCIONARIO
COFRE_FUNC:

		MOV A,@R0	      ; MOVER PARA ACC BYTE DE RECURSOS
		ANL A,#02h	      ; OBTER VALOR DO BIT UM (UM OU ZERO) PARA SABER SE É CLIENTE OU FUNCIONARIO
		JZ DISPLAY_FUNC	  ; SE  FOR ZERO, SALTA PARA LIGA DISPLAY FUNCIONARIO, E SIGNIFICA QUE O VALOR EM ACC É ZERO
		JMP COFRE		  ; SE NAO FOR ZERO SIGNIFICA QUE NAO É FUNCIONARIO E CONTINUA NORMALMENTE.
		 

;------------------------------------------------------------------------------------------------------
;LIGA DISPLAY DE FORMA A NAO APRECER NUMERO DO COFRE POIS É FUNCIONARIO
DISPLAY_FUNC:

		MOV A,#08h	         ; CONFIGURAÇÃO PARA SEGMENTO "A" LIGADO
		CPL A		         ; LÓGICA INVERTIDA DEVIDO AO DISPLAY
		MOV P1,A	         ; MOVER PARA O PORTO 1 
		CALL ESPERA	         ; COMPASSO ESPERA
		CALL ESPERA	         ;       "	"
		JMP DIGITO_SEPARACAO ;SALTA PARA DIGITO SEPARAÇÃO NAO PASSANDO POR "COFRE"

;---------------------------------------------------------------------------------------------------
;ROTINA QUE DÁ O VALOR DO COFRE E MOSTRA NO DISPLAY
COFRE:				 
		MOV A,@R0     ; MOVER PARA ACC O BYTE DE RECURSOS RECEBIDO
		SWAP A		  ; TROCAR A ORDEM DOS NIBBLES
		RR A		  ; ARRASTAR Á DIREITA UM BIT
		ANL A,#07h	  ; OBTEM-SE O NUMERO DO COFRE
	
		ADD A,R3      ; OBTER MASCARA PARA REPRESENTAR NUMERO NO DISPLAY
		MOV R1,A	  ; MOVER MASCARA PARA R1
		MOV A,@R1	  ; MOVER O CONTEUDO DA MASCARA PARA ACC
		CPL A		  ; COMPLEMENTO (LOGICA INVERTIDA)
		MOV P1,A	  ; OBTEM-SE O VALOR NO DISPLAY
		CALL ESPERA	  ;	COMPASSO DE ESPERA
		CALL ESPERA	  ;
;----------------------------------------------------------------------------------------------------		

;SEPARAR APRESENTAÇAO DO NUMERO DA SALA E COFRE DO RESTANTE (RECURSOS)
DIGITO_SEPARACAO:
		MOV P1,#0EFh   ; CONFIGURAÇÃO PARA SIMBOLO (-)
		CALL ESPERA	   ; COMPASSO DE ESPERA
		CALL ESPERA	   ;
;----------------------------------------------------------------------------------------------------

;ANALISAR OS BITS DO BYTE DE RECURSOS
BIT_0:
		MOV A,@R0	; MOVER PARA ACC BYTE DE RECURSOS
		ANL A,#01h	; OBTER VALOR DO BIT ZERO
		JNZ ROT0	; SE NAO FOR ZERO SALTA PARA ROT0
	

BIT_1:
		MOV A,@R0	; MOVER PARA ACC BYTE DE RECURSOS
		ANL A,#02h	; OBTER VALOR DO BIT UM
		JNZ ROT1	; SE NAO FOR ZERO SALTA PARA ROT1
	
BIT_2:
		MOV A,@R0	; MOVER PARA ACC BYTE DE RECURSOS
		ANL A,#04h	; OBTER VALOR DO BIT DOIS
		JNZ ROT2	; SE NAO FOR ZERO SALTA PARA ROT2
	
BIT_3:
		MOV A,@R0	; MOVER PARA ACC BYTE DE RECURSOS
		ANL A,#08h	; OBTER VALOR DO BIT TRES
		JNZ ROT3	; SE NAO FOR ZERO SALTA PARA ROT3

BIT_4:
		MOV A,@R0	; MOVER PARA ACC BYTE DE RECURSOS
		ANL A,#10h	; OBTER VALOR DO BIT QUATRO
		JNZ ROT4	; SE NAO FOR ZERO SALTA PARA ROT4
		JMP FIM_AUX	; SE FOR ZERO FINALIZA  

;--------------------------------------------------------------------------------------
; SEMPRE QUE ENTRA NESTAS ROTINAS SIGNIFICA QUE O ACC É DIFERENTE DE ZERO E LIGA O LED

ROT0:
		
		CALL LIGA_DISPLAY_0	; LIGAR DISPLAY CORRESPONDENTE AO RECURSO REPRESENTADO PELO BIT 0
		MOV P1,#0FFh	    ; DESLIGAR OS DISPLAYS (LOGICA INVERTIDA)
		Call BIT_1			; PASSAR PARA O BIT SEGUINTE

ROT1:  	
		 
		CALL LIGA_DISPLAY_1
		MOV P1,#0FFh
		Call BIT_2

ROT2:
		
		CALL LIGA_DISPLAY_2
		MOV P1,#0FFh
		Call BIT_3

ROT3:
		 
		CALL LIGA_DISPLAY_3
		MOV P1,#0FFh
		Call BIT_4


ROT4:
		
		CALL LIGA_DISPLAY_4
		MOV P1,#0FFh
		Call FIM_AUX

;------------------------------------------------------------------------------------
;ROTINAS PARA LIGAR OS DISPLAYS DOS BITS CORRESPONDENTES A CADA RECURSO ACTIVADOS (1)

;PORTA SALA
LIGA_DISPLAY_0:	   
			 
		    MOV A,#0D9h   ; CONFIGURAÇÃO PARA LETRA (S)	   
			CPL A		  ; COMPLEMENTO POIS OS DISPLAYS FUNCIONAM EM LOGICA INVERTIDA
			MOV P1,A	  ; MOVER ESSA CONFIGURAÇÃO PARA PORTO 1 PARA SER APRESENTADO
			CALL ESPERA	  ; COMPASSO DE ESPERA
			CALL ESPERA	  ;
			RET			  ;RETORNO
		

;PORTA COFRE
LIGA_DISPLAY_1:	 
			 
		    MOV A,#0E8h	   ; CONFIGURAÇÃO PARA LETRA (C)
			CPL A
			MOV P1,A
			CALL ESPERA
			CALL ESPERA
			RET

;LUZ 
LIGA_DISPLAY_2:	 
			 
		    MOV A,#0E0h     ; CONFIGURAÇÃO PARA LETRA (L)   
			CPL A
			MOV P1,A
			CALL ESPERA
			CALL ESPERA
			RET


;VIDEO VIGILANCIA
LIGA_DISPLAY_3:	
			 
		    MOV A,#0E5h     ; CONFIGURAÇÃO PARA LETRA (V)   
			CPL A
			MOV P1,A
			CALL ESPERA
			CALL ESPERA
			RET


;AR CONDICIONADO
LIGA_DISPLAY_4:	
			 
		    MOV A,#0BDh     ; CONFIGURAÇÃO PARA LETRA (A)	   
			CPL A
			MOV P1,A
			CALL ESPERA
			CALL ESPERA
			RET

;-------------------------------------------------------------

FIM_AUX:
		MOV P1,#047h	 ; CONFIGURAÇAO LETRA (F)
		CALL ESPERA		 ; COMPASSO DE ESPERA
		CALL ESPERA	     ; 
		;JMP FIM_AUX 
;--------------------------------------------------------------


MOV P1,#0FFh
LOGOUT:
		MOV R1,#056h	; NOVO PONTEIRO PARA INICIAR CODIGO DE LOGOUT 
		MOV R2, #4		; REPOSIÇAO DE VALORES NOS REGISTOS
		JMP LER_TECLA	; LER NOVAMENTE O CODIGO
		
 
;----------------------------------------------------------------------------------------------

END	 ; FIM DO PROGRAMA